<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Random Dice ðŸŽ²</title>
  <meta name="viewport" content="width=device-width,initial-scale=1.0">
  <meta name="theme-color" content="#000" />
  <link rel="manifest" href="manifest.json">
  <link rel="icon" href="dice.png">
  <style>
    html, body {
      height: 100%;
      margin: 0;
      background: #000;
      overflow: hidden;
      color: #fff;
      user-select: none;
      -webkit-user-select: none;
      touch-action: none;
    }
    #app {
      width: 100vw;
      height: 100vh;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
    }
    #dice-canvas {
      width: 140px;
      height: 140px;
      touch-action: none;
      background: transparent;
      display: block;
      margin: 0 auto;
    }
    #roll-btn {
      margin-top: 30px;
      background: #222;
      color: #fff;
      border: none;
      font-size: 22px;
      padding: 12px 36px;
      border-radius: 8px;
      cursor: pointer;
      letter-spacing: 1px;
      box-shadow: 0 2px 10px #0007;
      transition: background 0.2s;
    }
    #roll-btn:active {
      background: #444;
    }
    #indicator {
      position: fixed;
      top: 12px;
      right: 14px;
      width: 18px;
      height: 18px;
      border-radius: 50%;
      background: rgba(255,255,255,0.34);
      border: 1px solid rgba(255,255,255,0.12);
      z-index: 9999;
      display: none;
      pointer-events: none;
    }
    #setup-modal, #fix-modal {
      position: fixed;
      left: 0; top: 0; right: 0; bottom: 0;
      background: rgba(0,0,0,0.95);
      z-index: 10000;
      display: flex;
      align-items: center;
      justify-content: center;
      flex-direction: column;
    }
    .modal-content {
      background: #111d;
      padding: 32px 40px;
      border-radius: 16px;
      box-shadow: 0 2px 24px #000c;
      text-align: center;
    }
    .modal-content h2 {
      margin-top: 0;
      margin-bottom: 16px;
      font-size: 25px;
      color: #fff;
    }
    .number-grid {
      display: flex;
      gap: 20px;
      margin: 24px 0 12px 0;
      justify-content: center;
    }
    .number-btn {
      background: #fff;
      color: #222;
      font-size: 29px;
      width: 50px;
      height: 50px;
      border-radius: 50%;
      border: none;
      margin: 0 6px;
      box-shadow: 0 2px 7px #0008;
      cursor: pointer;
      outline: none;
      transition: background 0.12s;
    }
    .number-btn:active {
      background: #ddd;
    }
    .modal-content button {
      margin-top: 18px;
      font-size: 18px;
      border: none;
      background: #222;
      color: #fff;
      padding: 9px 25px;
      border-radius: 6px;
      cursor: pointer;
    }
    @media (max-width: 500px) {
      .modal-content { padding: 18px 6vw; }
      #dice-canvas { width: 110px; height: 110px; }
    }
  </style>
</head>
<body>
<div id="app">
  <canvas id="dice-canvas" width="160" height="160"></canvas>
  <button id="roll-btn">Roll Dice</button>
</div>
<div id="indicator"></div>
<div id="setup-modal" style="display:none;">
  <div class="modal-content">
    <h2>Setup: Fix a Number</h2>
    <p>Choose a number (1-6) to fix for magic.<br>
      This will remain secret until you activate it on stage.</p>
    <div class="number-grid" id="setup-numbers"></div>
    <button onclick="closeSetupModal()">Cancel</button>
  </div>
</div>
<div id="fix-modal" style="display:none;">
  <div class="modal-content">
    <h2>Magic Activated!</h2>
    <p>The fix is now ON.<br>Next roll will show your fixed number.</p>
    <button onclick="closeFixModal()">OK</button>
  </div>
</div>
<script type="module">
// --- PWA Install (minimal) ---
if ('serviceWorker' in navigator) {
  navigator.serviceWorker.register('sw.js');
}

// --- Dice 3D Logic ---
import * as THREE from 'https://cdn.jsdelivr.net/npm/three@0.156.1/build/three.module.js';
let scene, camera, renderer, diceMesh, rolling = false, currentValue = 1, lastRollTime=0;
let fixedNumber = null, fixedActive = false, fixIndicatorTimeout = null;
const diceCanvas = document.getElementById('dice-canvas');
const indicator = document.getElementById('indicator');
const rollBtn = document.getElementById('roll-btn');
const setupModal = document.getElementById('setup-modal');
const fixModal = document.getElementById('fix-modal');
const setupNumbers = document.getElementById('setup-numbers');

function createDiceMesh() {
  const dice = new THREE.Mesh(
    new THREE.BoxGeometry(1,1,1),
    [
      diceFaceMaterial(1), // right (X+)
      diceFaceMaterial(6), // left  (X-)
      diceFaceMaterial(3), // top   (Y+)
      diceFaceMaterial(4), // bottom(Y-)
      diceFaceMaterial(2), // front (Z+)
      diceFaceMaterial(5), // back  (Z-)
    ]
  );
  return dice;
}

// Helper to make dice face with dots
function diceFaceMaterial(num) {
  const size = 128, dot = 18;
  const canvas = document.createElement('canvas');
  canvas.width = canvas.height = size;
  const ctx = canvas.getContext('2d');
  ctx.fillStyle = "#fff";
  ctx.fillRect(0,0,size,size);
  ctx.fillStyle = "#000";
  // face dots: 3x3 grid
  const pos = [
    [size*0.25,size*0.25],[size*0.5,size*0.25],[size*0.75,size*0.25],
    [size*0.25,size*0.5], [size*0.5,size*0.5], [size*0.75,size*0.5],
    [size*0.25,size*0.75],[size*0.5,size*0.75],[size*0.75,size*0.75]
  ];
  // which dots for each face
  const map = {
    1: [4],
    2: [0,8],
    3: [0,4,8],
    4: [0,2,6,8],
    5: [0,2,4,6,8],
    6: [0,2,3,4,5,6,8].filter(i=>i!=4)
  };
  for(const i of map[num]) {
    ctx.beginPath();
    ctx.arc(pos[i][0],pos[i][1],dot,0,2*Math.PI);
    ctx.fill();
  }
  return new THREE.MeshBasicMaterial({map:new THREE.CanvasTexture(canvas)});
}

function randomDiceValue() {
  return Math.floor(Math.random()*6)+1;
}

// orientations for each face up (Y+)
const faceRotations = [
  {value:1, rot:[0,Math.PI/2,0]},
  {value:2, rot:[Math.PI/2,0,0]},
  {value:3, rot:[0,0,0]},
  {value:4, rot:[Math.PI,0,0]},
  {value:5, rot:[0,0,Math.PI/2]},
  {value:6, rot:[0,-Math.PI/2,0]}
];
function getRotationForValue(val) {
  return faceRotations.find(f=>f.value===val).rot;
}

function animateDiceRoll(targetValue, cb) {
  rolling = true;
  let t = 0;
  const start = performance.now();
  const duration = 900 + Math.random()*350;
  const [rx,ry,rz] = getRotationForValue(targetValue);
  const sx = diceMesh.rotation.x, sy = diceMesh.rotation.y, sz = diceMesh.rotation.z;
  function anim(now) {
    t = Math.min(1, (now-start)/duration);
    // randomize a bit then go to target
    diceMesh.rotation.x = sx*(1-t) + (rx+Math.PI*4)*t;
    diceMesh.rotation.y = sy*(1-t) + (ry+Math.PI*4)*t;
    diceMesh.rotation.z = sz*(1-t) + (rz+Math.PI*4)*t;
    renderer.render(scene, camera);
    if(t<1) requestAnimationFrame(anim); else {
      diceMesh.rotation.x = rx;
      diceMesh.rotation.y = ry;
      diceMesh.rotation.z = rz;
      renderer.render(scene, camera);
      currentValue = targetValue;
      rolling = false;
      if(cb) cb();
    }
  }
  requestAnimationFrame(anim);
}

// --- ThreeJS Dice Setup ---
function initDice() {
  scene = new THREE.Scene();
  camera = new THREE.PerspectiveCamera(40, diceCanvas.width/diceCanvas.height, 0.1, 100);
  camera.position.set(0,0,3.4);
  renderer = new THREE.WebGLRenderer({canvas:diceCanvas, alpha:true, antialias:true});
  renderer.setClearColor(0x000000, 0);
  diceMesh = createDiceMesh();
  scene.add(diceMesh);
  // subtle shadow
  const light = new THREE.DirectionalLight(0xffffff, 0.74);
  light.position.set(3,6,6).normalize();
  scene.add(light);
  // touch/drag to rotate
  let drag=false, lx=0, ly=0;
  diceCanvas.addEventListener('pointerdown', e=>{
    drag=true; lx=e.clientX; ly=e.clientY;
  });
  diceCanvas.addEventListener('pointermove', e=>{
    if(drag && !rolling){
      diceMesh.rotation.y += (e.clientX-lx)*0.012;
      diceMesh.rotation.x += (e.clientY-ly)*0.012;
      lx = e.clientX; ly = e.clientY;
      renderer.render(scene, camera);
    }
  });
  diceCanvas.addEventListener('pointerup', ()=>{ drag=false; });
  diceCanvas.addEventListener('pointerleave', ()=>{ drag=false; });
  renderer.render(scene, camera);
}
initDice();

// --- Roll Dice Logic ---
async function rollDice() {
  if (rolling) return;
  let showValue;
  if (fixedActive) {
    showValue = fixedNumber;
    fixedActive = false;
    indicator.style.display = 'none';
    setTimeout(()=>{ indicator.style.display='none'; }, 300);
  }
  else showValue = randomDiceValue();
  animateDiceRoll(showValue);
}
rollBtn.addEventListener('click', rollDice);

// --- Fixed Number HIDDEN Activation ---
let pressTimer = null;
let pressStart = 0;
document.body.addEventListener('pointerdown', e => {
  if (e.target===rollBtn) return;
  pressStart = Date.now();
  pressTimer = setTimeout(()=>{
    if(fixedNumber!==null){
      fixedActive = true;
      indicator.style.display = 'block';
      fixModal.style.display = 'flex';
    }
  }, 1700); // 1.7 sec press anywhere (not on button)
});
document.body.addEventListener('pointerup', () => {
  clearTimeout(pressTimer);
});

// Hide indicator after fix number appears
function showIndicator() {
  indicator.style.display = 'block';
  if (fixIndicatorTimeout) clearTimeout(fixIndicatorTimeout);
  fixIndicatorTimeout = setTimeout(()=>indicator.style.display='none', 2000);
}

// --- Setup Hidden Tap Sequence (5 taps to open setup) ---
let tapCount=0, tapTimeout=null;
document.body.addEventListener('pointerdown', function(e){
  if(e.target===rollBtn) return;
  tapCount++;
  if(tapTimeout) clearTimeout(tapTimeout);
  tapTimeout = setTimeout(()=>tapCount=0, 1100);
  if(tapCount===5){
    tapCount=0;
    openSetupModal();
  }
});

// --- Setup Modal ---
function openSetupModal(){
  setupModal.style.display='flex';
  setupNumbers.innerHTML = '';
  for(let i=1;i<=6;i++){
    const btn = document.createElement('button');
    btn.className = 'number-btn';
    btn.innerText = i;
    btn.onclick = ()=>selectFixedNumber(i);
    setupNumbers.appendChild(btn);
  }
}
function selectFixedNumber(num){
  fixedNumber = num;
  localStorage.setItem('fixNum', num);
  setupModal.style.display='none';
  alert('Fixed number set! Now you can activate magic during performance.');
}
function closeSetupModal(){ setupModal.style.display='none'; }

// --- Fix Modal ---
function closeFixModal(){
  fixModal.style.display='none';
  indicator.style.display='block';
  setTimeout(()=>indicator.style.display='none', 1900);
}

// --- PERSIST: retain fixed number across reloads ---
window.addEventListener('DOMContentLoaded', ()=>{
  const savedNum = +localStorage.getItem('fixNum');
  if(savedNum>=1 && savedNum<=6) fixedNumber = savedNum;
});

// --- Fullscreen Experience ---
function requestFullscreen() {
  if(document.fullscreenElement) return;
  const el = document.documentElement;
  if(el.requestFullscreen) el.requestFullscreen();
  else if(el.webkitRequestFullscreen) el.webkitRequestFullscreen();
}
window.addEventListener('click', requestFullscreen, { once:true });

// --- Prevent double tap zoom on mobile ---
let lastTouch=0;
document.body.addEventListener('touchend', e=>{
  const now = Date.now();
  if(now-lastTouch<400) e.preventDefault();
  lastTouch = now;
}, {passive:false});
</script>

<!-- PWA Manifest and Service Worker -->
<script>
  // Quick inline manifest for PWA, add to home screen
  const manifest = {
    "name": "Random Dice",
    "short_name": "Random Dice",
    "start_url": ".",
    "display": "standalone",
    "background_color": "#000",
    "theme_color": "#000",
    "icons": [
      { "src": "dice.png", "sizes": "192x192", "type": "image/png" },
      { "src": "dice.png", "sizes": "512x512", "type": "image/png" }
    ]
  };
  const blob = new Blob([JSON.stringify(manifest)], { type: "application/json" });
  const manifestURL = URL.createObjectURL(blob);
  document.querySelector('link[rel="manifest"]').setAttribute('href', manifestURL);
</script>
</body>
</html>
